# /etc/skel/.bashrc
#
# This file is sourced by all *interactive* bash shells on startup,
# including some apparently interactive shells such as scp and rcp
# that can't tolerate any output.  So make sure this doesn't display
# anything or bad things will happen !


# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]] ; then
	# Shell is non-interactive.  Be done now!
	return
fi
# Put your fun stuff here.

if uname -a | grep -q SAMSUNG ; then
#  echo "Booting into ChromeOS Linux"
	 sudo mount -i -o remount,exec /home/chronos/user/  

	#
	# Optional launch into ArchLinux...
	#

	_key()
	{
	  local kp
	  ESC=$'\e'
	  _KEY=
	  read -d '' -sn1 _KEY
	  case $_KEY in
	    "$ESC")
		while read -d '' -sn1 -t1 kp
		do
		  _KEY=$_KEY$kp
		  case $kp in
		    [a-zA-NP-Z~]) break;;
		  esac
		done
	    ;;
	  esac
	  printf -v "${1:-_KEY}" "%s" "$_KEY"
	}

	echo "Press ESC to continue to ChromeOS (default). Any other key for Arch Linux."

	_key x

	case $x in
	  $'\e[11~' | $'\e[OP') key=F1 ;;
	  $'\e[12~' | $'\e[OQ') key=F2 ;;
	  $'\e[13~' | $'\e[OR') key=F3 ;;
	  $'\e[14~' | $'\e[OS') key=F4 ;;
	  $'\e[15~') key=F5 ;;
	  $'\e[16~') key=F6 ;;
	  $'\e[17~') key=F7 ;;
	  $'\e[18~') key=F8 ;;
	  $'\e[19~') key=F9 ;;
	  $'\e[20~') key=F10 ;;
	  $'\e[21~') key=F11 ;;
	  $'\e[22~') key=F12 ;;
	  $'\e') key=ESC ;;
	  $'\e[A' ) key=UP ;;
	  $'\e[B' ) key=DOWN ;;
	  $'\e[C' ) key=RIGHT ;;
	  $'\e[D' ) key=LEFT ;;
	  ?) key=$x ;;
	  *) key=??? ;;
	esac

	if [ "$key" == "ESC" ]; then
	  echo "Starting ChromeOS root..."
	else
	    echo "Launching Arch Linux..."
	    /bin/sh ~/local-dev/scripts/go2arch.sh
	fi

#--------------------------------
# Continue for Arch Linux only
#--------------------------------
else
	echo "Welcome to Arch Linux: `uname -a`"
	# Configure colors, if available.
	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	  c_reset='\[\e[0m\]'
	  c_user='\[\e[1;33m\]'
	  c_path='\[\e[0;33m\]'
	  c_git_cleancleann='\[\e[0;36m\]'
	  c_git_dirty='\[\e[0;35m\]'
	else
	  c_reset=
	  c_user=
	  c_git_cleancleann_path=
	  c_git_clean=
	  c_git_dirty=
	fi
	# Function to assemble the Git parsingart of our prompt.
	git_prompt ()
	{
	  if ! git rev-parse --git-dir > /dev/null 2>&1; then
	    return 0
	  fi
	  git_branch=$(git branch 2>/dev/null | sed -n '/^\*/s/^\* //p')
	  if git diff --quiet 2>/dev/null >&2; then
	    git_color="$c_git_clean"
	  else
	    git_color="$c_git_dirty"
	  fi
	  echo "[$git_color$git_branch${c_reset}]"
	}
	# Thy holy prompt.
	PROMPT_COMMAND='PS1="${c_user}\u${c_reset}@${c_user}\h${c_reset}:${c_path}\w${c_reset}$(git_prompt)\$ "'

	# Alias Setup
	alias anno2go='. /root/local-dev/scripts/annotum2go.sh'
	alias anno2stop='. /root/local-dev/scripts/annotum2stop.sh'
	alias apacherestart='/etc/rc.d/httpd restart'
	alias gem='gem --no-user-install'
	alias go="~/local-dev/scripts/go"
	alias godev='cd ~/local-dev'
	alias gonode='cd ~/local-dev/node-dev'
	alias gohome='cd ~'
	alias goanno='cd /srv/http/wordpress/wp-content/themes/'
	alias l.='ls -d .* --color=auto'
	alias ll='ls -l --color=auto'
	alias ls='ls --color=auto'
	alias vi='vim'
	alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'

	# export PATH=$PATH:/root/.gem/ruby/1.9.1/gems
	export EC2_HOME=~/.ec2
	export PATH=$PATH:$EC2_HOME/bin
	export EC2_PRIVATE_KEY=$EC2_HOME/pk-GTWUAWNOHYXXMN6B254TNGE2C7WCHVW3.pem
	export EC2_CERT=$EC2_HOME/cert-GTWUAWNOHYXXMN6B254TNGE2C7WCHVW3.pem
	#Java home for debian default install path:
	#export JAVA_HOME=/opt/java
	#add ec2 tools to default path
	export PATH=~/.ec2/bin:$PATH
fi # end of Arch Stuff
cd ~
